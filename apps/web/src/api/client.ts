const API_URL = import.meta.env.VITE_API_URL || ''

interface Engagement {
  id: string
  clientName: string
  clientEmail: string
  taxYear: number
  status: string
  storageProvider: string
  storageFolderUrl: string
  typeformFormId: string
  checklist: ChecklistItem[] | null
  documents: Document[] | null
  reconciliation: Reconciliation | null
  prepBrief: string | null
  createdAt: string
  updatedAt: string
}

interface ChecklistItem {
  id: string
  title: string
  why: string
  priority: 'high' | 'medium' | 'low'
  status: 'pending' | 'received' | 'complete'
  documentIds: string[]
}

// Shared constant for document types
const DOCUMENT_TYPES = ['W-2', '1099-NEC', '1099-MISC', '1099-INT', 'K-1', 'RECEIPT', 'STATEMENT', 'OTHER', 'PENDING'] as const
type DocumentType = (typeof DOCUMENT_TYPES)[number]

interface DocumentOverride {
  originalType: string
  reason: string
}

// Friendly issue messages generated by LLM
interface FriendlyIssue {
  original: string
  friendlyMessage: string
  suggestedAction: string
  severity: 'error' | 'warning'
}

interface Document {
  id: string
  fileName: string
  storageItemId: string
  documentType: string
  confidence: number
  taxYear: number | null
  issues: string[]
  issueDetails: FriendlyIssue[] | null // Cached LLM-generated issue details
  classifiedAt: string | null
  processingStatus?: 'pending' | 'in_progress' | 'classified' | 'error'
  processingStartedAt?: string | null
  // Document review fields
  approved: boolean | null
  approvedAt: string | null
  override: DocumentOverride | null
}

interface Reconciliation {
  completionPercentage: number
  itemStatuses: Array<{
    itemId: string
    status: 'pending' | 'received' | 'complete'
    documentIds: string[]
  }>
  issues: string[]
  ranAt: string
}

interface CreateEngagementData {
  clientName: string
  clientEmail: string
  storageFolderUrl: string
}

async function fetchApi<T>(path: string, options?: RequestInit): Promise<T> {
  const response = await fetch(`${API_URL}${path}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  })

  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({ error: 'Unknown error' }))
    // Handle different error formats (string, object with message, Zod validation errors)
    let errorMessage: string
    if (typeof errorBody.error === 'string') {
      errorMessage = errorBody.error
    } else if (errorBody.error?.message) {
      errorMessage = errorBody.error.message
    } else if (errorBody.success === false && errorBody.error) {
      // Zod validation format from @hono/zod-validator
      errorMessage = 'Validation failed: ' + JSON.stringify(errorBody.error)
    } else {
      errorMessage = `HTTP ${response.status}`
    }
    throw new Error(errorMessage)
  }

  return response.json()
}

export async function getEngagements(): Promise<Engagement[]> {
  return fetchApi('/api/engagements')
}

export async function getEngagement(id: string): Promise<Engagement> {
  return fetchApi(`/api/engagements/${id}`)
}

export async function createEngagement(data: CreateEngagementData): Promise<Engagement> {
  return fetchApi('/api/engagements', {
    method: 'POST',
    body: JSON.stringify(data),
  })
}

export async function generateBrief(id: string): Promise<{ success: boolean; brief: string }> {
  return fetchApi(`/api/engagements/${id}/brief`, {
    method: 'POST',
  })
}

// Document review actions
export async function approveDocument(
  engagementId: string,
  docId: string
): Promise<{ success: boolean; document: Document }> {
  return fetchApi(`/api/engagements/${engagementId}/documents/${docId}/approve`, {
    method: 'POST',
  })
}

export async function reclassifyDocument(
  engagementId: string,
  docId: string,
  newType: string
): Promise<{ success: boolean; document: Document }> {
  return fetchApi(`/api/engagements/${engagementId}/documents/${docId}/reclassify`, {
    method: 'POST',
    body: JSON.stringify({ newType }),
  })
}

export interface EmailPreview {
  subject: string
  body: string
  recipientEmail: string
  uploadUrl: string
}

export async function getEmailPreview(
  engagementId: string,
  docId: string
): Promise<EmailPreview> {
  return fetchApi(`/api/engagements/${engagementId}/documents/${docId}/email-preview`)
}

export async function sendDocumentFollowUp(
  engagementId: string,
  docId: string,
  options: { email?: string; subject?: string; body?: string }
): Promise<{ success: boolean; message: string }> {
  return fetchApi(`/api/engagements/${engagementId}/documents/${docId}/send-followup`, {
    method: 'POST',
    body: JSON.stringify(options),
  })
}

export async function getFriendlyIssues(
  engagementId: string,
  docId: string
): Promise<{ issues: FriendlyIssue[] }> {
  return fetchApi(`/api/engagements/${engagementId}/documents/${docId}/friendly-issues`)
}

export async function processEngagement(id: string): Promise<{ success: boolean; totalDocuments: number; pendingDocuments: number }> {
  return fetchApi(`/api/engagements/${id}/process`, {
    method: 'POST',
  })
}

export async function retryDocument(
  engagementId: string,
  docId: string
): Promise<{ success: boolean; document: Document }> {
  return fetchApi(`/api/engagements/${engagementId}/documents/${docId}/retry`, {
    method: 'POST',
  })
}

export { DOCUMENT_TYPES }
export type { Engagement, ChecklistItem, Document, DocumentType, DocumentOverride, FriendlyIssue, Reconciliation, CreateEngagementData }
